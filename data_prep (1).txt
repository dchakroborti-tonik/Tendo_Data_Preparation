import pandas as pd
import numpy as np
from typing import Tuple

# ============================================================
# Data Preparation Pipeline for Target Calculation
# ============================================================

def prepare_data_for_target_calculation(dt: pd.DataFrame,
                                        dt_repayments: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Prepare inputs for the `compute_user_targets` function.

    This routine keeps **only** the transformations required for target labeling and
    returns two slim dataframes:

      1) `dt_clean`  with columns: ['ee_customer_id', 'ee_resignation_date_correct']
      2) `dt_repayments_clean` with columns:
         ['user_id','loan_id','installment_number','vendor_id','repaid_date','due_date','osbal_after']

    Parameters
    ----------
    dt : pd.DataFrame
        Customer / loan-level table. Must contain at least:
          - IDs & mapping:  ee_customer_id, ln_loan_id
          - Principal:      ln_original_principal
          - Employment:     ee_product_type, ee_onboarding_date, ee_employment_date
          - Resignation:    ee_resignation_date, ee_permanent_freeze_date
    dt_repayments : pd.DataFrame
        Repayment transactions table. Must contain at least:
          - Keys:           user_id, loan_id, installment_number
          - Vendor & dates: vendor_id, repaid_date, due_date
          - Payments:       paid_principal

    Returns
    -------
    tuple[pd.DataFrame, pd.DataFrame]
        A pair `(dt_clean, dt_repayments_clean)` where:
          - dt_clean:
              ['ee_customer_id', 'ee_resignation_date_correct']
          - dt_repayments_clean:
              ['user_id','loan_id','installment_number','vendor_id','repaid_date','due_date','osbal_after']

    Processing Steps (kept intentionally minimal)
    ---------------------------------------------
    A) `dt` (customer/employer table)
       1. Filter to `ee_product_type == 'employer'` and non-null `ee_onboarding_date`
          (mirrors your business rule / original behavior).
       2. Normalize select string/date/number columns (only those needed downstream).
       3. Build `ee_resignation_date_correct` as:
             COALESCE(ee_resignation_date, ee_permanent_freeze_date).
       4. Impute resignations from TPSD→TPFP transitions (derived from repayments) and
          fill any remaining nulls in `ee_resignation_date_correct`.
       5. Keep only `['ee_customer_id','ee_resignation_date_correct']`.

    B) `dt_repayments` (transactions)
       1. Sort **exactly** by ['loan_id','repaid_date','installment_number'] to ensure
          a stable order for cumulative sums and vendor transitions.
       2. Pull `ln_original_principal` from `dt` and compute:
            cumulative_paid_principal = cumsum(paid_principal) over loan_id
            osbal_after               = ln_original_principal - cumulative_paid_principal
       3. Detect TPSD→TPFP transitions using shifted vendor columns and use those
          to impute the resignation month+1 at the user level.
       4. Keep only:
            ['user_id','loan_id','installment_number','vendor_id','repaid_date','due_date','osbal_after'].   

    """

    # ============================================================
    # PART 1: Prepare dt DataFrame
    # ============================================================

    # Filter to employer product type only (business requirement)
    dt = dt[dt['ee_product_type'] == 'employer']
    dt = dt[dt['ee_onboarding_date'].notna()].reset_index(drop=True)

    # Define columns needed for target calculation
    str_columns_needed = ['ee_customer_id', 'ln_loan_id']  # ln_loan_id needed for merge
    date_columns_needed = ['ee_resignation_date', 'ee_permanent_freeze_date',
                           'ee_onboarding_date', 'ee_employment_date']
    num_columns_needed = ['ln_original_principal']  # Needed for osbal calculation

    # Handle missing values in string columns (only for needed columns)
    missing_values = ['<NA>', 'None', 'NaN', 'nan', '', 'null', 'NULL']
    dt[str_columns_needed] = dt[str_columns_needed].replace(missing_values, np.nan).astype('string')

    # Convert date columns (only the ones needed)
    dt['ee_resignation_date'] = pd.to_datetime(dt['ee_resignation_date'], format='%Y-%m-%d', errors='coerce')

    # Localize date columns (remove timezone info)
    localize_cols_needed = ['ee_permanent_freeze_date', 'ee_onboarding_date']
    for col in localize_cols_needed:
        dt[col] = dt[col].dt.tz_localize(None)

    # Convert employment_date
    dt['ee_employment_date'] = pd.to_datetime(dt['ee_employment_date'], format='%Y-%m-%d', errors='coerce')

    # Convert numeric columns (needed for osbal calculation)
    dt[num_columns_needed] = dt[num_columns_needed].astype('float')

    # Create ee_employment_date_correct (kept for parity with your prep; not used downstream)
    dt['ee_employment_date_correct'] = pd.to_datetime(
        dt[['ee_onboarding_date', 'ee_employment_date']].min(axis=1).dt.date
    )

    # Initial ee_resignation_date_correct (before TPFP adjustment)
    dt['ee_resignation_date_correct'] = dt['ee_resignation_date'].fillna(dt['ee_permanent_freeze_date'])

    # ============================================================
    # PART 2: Prepare dt_repayments DataFrame
    # ============================================================

    # Sort values (mandatory for correct cumulative calculations & transitions)
    dt_repayments = dt_repayments.sort_values(['loan_id', 'repaid_date', 'installment_number'])

    # Convert IDs to string for alignment
    dt_repayments['loan_id'] = dt_repayments['loan_id'].astype('str')
    dt_repayments['user_id'] = dt_repayments['user_id'].astype('str')

    # Merge with loan data to get original principal (needed for osbal calculations)
    dt_repayments = dt_repayments.merge(
        dt[['ln_loan_id', 'ln_original_principal']].drop_duplicates(),
        how='left',
        left_on='loan_id',
        right_on='ln_loan_id'
    )

    # Convert dates
    dt_repayments['repaid_date'] = pd.to_datetime(dt_repayments['repaid_date'], format='%Y-%m-%d')
    dt_repayments['due_date'] = pd.to_datetime(dt_repayments['due_date'], format='%Y-%m-%d')

    # ============================================================
    # PART 3: Calculate osbal_after 
    # ============================================================

    # Calculate cumulative paid amount per loan
    dt_repayments['cumulative_paid_principal'] = dt_repayments.groupby('loan_id')['paid_principal'].cumsum()

    # Calculate osbal_after directly from loan_amount - cumulative_paid
    dt_repayments['osbal_after'] = dt_repayments['ln_original_principal'] - dt_repayments['cumulative_paid_principal']

    # Calculate osbal_before by shifting osbal_after (kept for parity; not used downstream)
    dt_repayments['osbal_before'] = dt_repayments.groupby('loan_id')['osbal_after'].shift(1)

    # Fill first payment osbal_before with loan_amount
    mask = dt_repayments['osbal_before'].isna()
    dt_repayments.loc[mask, 'osbal_before'] = dt_repayments.loc[mask, 'ln_original_principal']

    # ============================================================
    # PART 4: Resignation date correction based on TPSD->TPFP transition
    # ============================================================

    # Create shifted columns for vendor transition detection
    dt_repayments['vendor_id_shifted'] = dt_repayments.groupby('loan_id')['vendor_id'].shift(-1)
    dt_repayments['repaid_date_shifted'] = dt_repayments.groupby('loan_id')['repaid_date'].shift(-1)

    # Find users who resigned based on TPSD->TPFP transition
    resigned_dt = (
        dt_repayments[['user_id', 'loan_id', 'vendor_id', 'vendor_id_shifted', 'repaid_date']]
        .query('vendor_id == "TPSD"')
        .fillna('TPSD')
        .query('vendor_id != vendor_id_shifted & vendor_id_shifted == "TPFP"')
        .assign(resignation_date_fp_new=lambda x: x['repaid_date'] + pd.DateOffset(months=1))
        .groupby('user_id')[['resignation_date_fp_new']]
        .max()
        .reset_index()
    )

    # Update resignation date with TPFP-based resignation
    dt = dt.merge(resigned_dt, how='left', left_on='ee_customer_id', right_on='user_id')
    dt['ee_resignation_date_correct'] = dt['ee_resignation_date_correct'].fillna(dt['resignation_date_fp_new'])

    # ============================================================
    # PART 5: Keep only necessary columns for target calculation
    # ============================================================

    # For dt: keep only what's needed
    dt_clean = dt[['ee_customer_id', 'ee_resignation_date_correct']].copy()

    # For dt_repayments: keep only what's needed
    repayments_final_columns = [
        'user_id', 'loan_id', 'installment_number', 'vendor_id',
        'repaid_date', 'due_date', 'osbal_after'
    ]
    dt_repayments_clean = dt_repayments[repayments_final_columns].copy()

    return dt_clean, dt_repayments_clean
